<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TermX (MacOS)</title>
  <link rel="stylesheet" href="style.css">
  <meta name="google-site-verification" content="khV76BTjy8gt0uqmbhU3k6r3KbBZMDV3NlGX2wKs8xg" />
</head>

<body>
  <script src="main.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script>
    const ver = 'v4.1.0',
      username = 'root',
      icons = {
        arrowUp: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 11.0001L12 6.00006L17 11.0001M12 18.0001V6.00006" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
        arrowDown: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 13L12 18L17 13M12 6L12 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
        arrowLeft: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.0001 7L6.00006 12L11.0001 17M18.0001 12L6.00006 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
        arrowRight: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 7L18 12L13 17M6 12H18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
        enter: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 12h-9m0 0l4 4m-4-4l4-4M19 18v3a1 1 0 01-1 1H6a1 1 0 01-1-1V3a1 1 0 011-1h12a1 1 0 011 1v3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
        openFile: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M19,19V5H5V19H19M19,3A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3H19M11,8H13V11H16V13H13V16H11V13H8V11H11V8Z"/></svg>',
        openFolder: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 .087.586l2.977-7.937A1 1 0 0 1 6 10h12V9a2 2 0 0 0-2-2h-4.532l-1.9-2.28A2 2 0 0 0 8.032 4H4Zm2.693 8H6.5l-3 8H18l3-8H6.693Z" clip-rule="evenodd"/></svg>',
        openAs: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M11.403 5H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6.403a3.01 3.01 0 0 1-1.743-1.612l-3.025 3.025A3 3 0 1 1 9.99 9.768l3.025-3.025A3.01 3.01 0 0 1 11.403 5Z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M13.232 4a1 1 0 0 1 1-1H20a1 1 0 0 1 1 1v5.768a1 1 0 1 1-2 0V6.414l-6.182 6.182a1 1 0 0 1-1.414-1.414L17.586 5h-3.354a1 1 0 0 1-1-1Z" clip-rule="evenodd"/></svg>',
        rename: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M16.84,2.73C16.45,2.73 16.07,2.88 15.77,3.17L13.65,5.29L18.95,10.6L21.07,8.5C21.67,7.89 21.67,6.94 21.07,6.36L17.9,3.17C17.6,2.88 17.22,2.73 16.84,2.73M12.94,6L4.84,14.11L7.4,14.39L7.58,16.68L9.86,16.85L10.15,19.41L18.25,11.3M4.25,15.04L2.5,21.73L9.2,19.94L8.96,17.78L6.65,17.61L6.47,15.29"/></svg>',
        delete: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/></svg>',
        refresh: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 19.73,14.65H17.65A6,6 0 0,1 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/></svg>',
        newFolder: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M5 4a2 2 0 0 0-2 2v1h10.968l-1.9-2.28A2 2 0 0 0 10.532 4H5ZM3 19V9h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm9-8.5a1 1 0 0 1 1 1V13h1.5a1 1 0 1 1 0 2H13v1.5a1 1 0 1 1-2 0V15H9.5a1 1 0 1 1 0-2H11v-1.5a1 1 0 0 1 1-1Z" clip-rule="evenodd"/></svg>',
        newFile: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v6.41A7.5 7.5 0 1 0 10.5 22H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M9 16a6 6 0 1 1 12 0 6 6 0 0 1-12 0Zm6-3a1 1 0 0 1 1 1v1h1a1 1 0 1 1 0 2h-1v1a1 1 0 1 1-2 0v-1h-1a1 1 0 1 1 0-2h1v-1a1 1 0 0 1 1-1Z" clip-rule="evenodd"/></svg>',
        folder: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.5 8H4m0-2v13a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-5.032a1 1 0 0 1-.768-.36l-1.9-2.28a1 1 0 0 0-.768-.36H5a1 1 0 0 0-1 1Z"/></svg>',
        audio: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 18c0 1.1046-.89543 2-2 2s-2-.8954-2-2 .89543-2 2-2 2 .8954 2 2Zm0 0V6.33333L18 4v11.6667M8 10.3333 18 8m0 8c0 1.1046-.8954 2-2 2s-2-.8954-2-2 .8954-2 2-2 2 .8954 2 2Z"/></svg>',
        image: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M13 10a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H14a1 1 0 0 1-1-1Z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12c0 .556-.227 1.06-.593 1.422A.999.999 0 0 1 20.5 20H4a2.002 2.002 0 0 1-2-2V6Zm6.892 12 3.833-5.356-3.99-4.322a1 1 0 0 0-1.549.097L4 12.879V6h16v9.95l-3.257-3.619a1 1 0 0 0-1.557.088L11.2 18H8.892Z" clip-rule="evenodd"/></svg>',
        video: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M19.003 3A2 2 0 0 1 21 5v2h-2V5.414L17.414 7h-2.828l2-2h-2.172l-2 2H9.586l2-2H9.414l-2 2H3V5a2 2 0 0 1 2-2h14.003ZM3 9v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9H3Zm2-2.414L6.586 5H5v1.586Zm4.553 4.52a1 1 0 0 1 1.047.094l4 3a1 1 0 0 1 0 1.6l-4 3A1 1 0 0 1 9 18v-6a1 1 0 0 1 .553-.894Z" clip-rule="evenodd"/></svg>',
        camera: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M14 7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7Zm2 9.387 4.684 1.562A1 1 0 0 0 22 17V7a1 1 0 0 0-1.316-.949L16 7.613v8.774Z" clip-rule="evenodd"/></svg>',
        text: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14,17H7V15H14M17,13H7V11H17M17,9H7V7H17M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z" fill="currentColor"/></svg>',
        terminal: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M3 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H3Zm4.293 5.707a1 1 0 0 1 1.414-1.414l3 3a1 1 0 0 1 0 1.414l-3 3a1 1 0 0 1-1.414-1.414L9.586 12 7.293 9.707ZM13 14a1 1 0 1 0 0 2h3a1 1 0 1 0 0-2h-3Z" clip-rule="evenodd"/></svg>',
        explorer: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M5.024 3.783A1 1 0 0 1 6 3h12a1 1 0 0 1 .976.783L20.802 12h-4.244a1.99 1.99 0 0 0-1.824 1.205 2.978 2.978 0 0 1-5.468 0A1.991 1.991 0 0 0 7.442 12H3.198l1.826-8.217ZM3 14v5a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-5h-4.43a4.978 4.978 0 0 1-9.14 0H3Z" clip-rule="evenodd"/></svg>',
        fileUnvalid: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linejoin="round" stroke-width="2" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"/></svg>',
        fileVideo: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linejoin="round" stroke-width="2" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1ZM9 12h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1Zm5.697 2.395v-.733l1.269-1.219v2.984l-1.268-1.032Z"/></svg>',
        fileImage: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill="currentColor" d="M16 18H8l2.5-6 2 4 1.5-2 2 4Zm-1-8.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1ZM8 18h8l-2-4-1.5 2-2-4L8 18Zm7-8.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z"/></svg>',
        fileAudio: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 3v4a1 1 0 0 1-1 1H5m8 7.5V8s3 1 3 4m3-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Zm-6 12c0 1.105-1.12 2-2.5 2S8 17.105 8 16s1.12-2 2.5-2 2.5.895 2.5 2Z"/></svg>',
        fileArchive: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Zm-4 1h.01v.01H15V5Zm-2 2h.01v.01H13V7Zm2 2h.01v.01H15V9Zm-2 2h.01v.01H13V11Zm2 2h.01v.01H15V13Zm-2 2h.01v.01H13V15Zm2 2h.01v.01H15V17Zm-2 2h.01v.01H13V19Z"/></svg>',
        fileText: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 3v4a1 1 0 0 1-1 1H5m4 8h6m-6-4h6m4-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"/></svg>',
        fileExecutable: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 3v4a1 1 0 0 1-1 1H5m5 4-2 2 2 2m4-4 2 2-2 2m5-12v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"/></svg>',
        settings: '<svg width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/></svg>',
        fullscreen: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" d="M8 4H4m0 0v4m0-4 5 5m7-5h4m0 0v4m0-4-5 5M8 20H4m0 0v-4m0 4 5-5m7 5h4m0 0v-4m0 4-5-5"/></svg>',
        minFullscreen: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" d="M4 8h4V4m12 4h-4V4M4 16h4v4m12-4h-4v4"/></svg>',
        volumeMute: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" d="M15.5 8.43A4.985 4.985 0 0 1 17 12c0 1.126-.5 2.5-1.5 3.5m2.864-9.864A8.972 8.972 0 0 1 21 12c0 2.023-.5 4.5-2.5 6M7.8 7.5l2.56-2.133a1 1 0 0 1 1.64.768V12m0 4.5v1.365a1 1 0 0 1-1.64.768L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1m1-4 14 14"/></svg>',
        volumeDown: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" d="M17.5 8.43A4.985 4.985 0 0 1 19 12a4.984 4.984 0 0 1-1.43 3.5M14 6.135v11.73a1 1 0 0 1-1.64.768L8 15H6a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l4.36-3.633a1 1 0 0 1 1.64.768Z"/></svg>',
        volumeUp: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" d="M15.5 8.43A4.985 4.985 0 0 1 17 12a4.984 4.984 0 0 1-1.43 3.5m2.794 2.864A8.972 8.972 0 0 0 21 12a8.972 8.972 0 0 0-2.636-6.364M12 6.135v11.73a1 1 0 0 1-1.64.768L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l4.36-3.633a1 1 0 0 1 1.64.768Z"/></svg>',
        pause: '<svg style="transform: translateX(1px);" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M8.6 5.2A1 1 0 0 0 7 6v12a1 1 0 0 0 1.6.8l8-6a1 1 0 0 0 0-1.6l-8-6Z" clip-rule="evenodd"/></svg>',
        play: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M8 5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2H8Zm7 0a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-1Z" clip-rule="evenodd"/></svg>',
        copy: '<svg width="64px" height="64px" viewBox="-2.4 -2.4 28.80 28.80" stroke="currentColor" fill="none" xmlns="http://www.w3.org/2000/svg" transform="matrix(1, 0, 0, 1, 0, 0)rotate(0)"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round" stroke="#ffff00" stroke-width="0.43200000000000005"></g><g id="SVGRepo_iconCarrier"> <path d="M3 16V4C3 2.89543 3.89543 2 5 2H15M9 22H18C19.1046 22 20 21.1046 20 20V8C20 6.89543 19.1046 6 18 6H9C7.89543 6 7 6.89543 7 8V20C7 21.1046 7.89543 22 9 22Z" stroke-width="1.9200000000000004" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>',
        copyFile: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M7 9v6a4 4 0 0 0 4 4h4a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1v2Z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M13 3.054V7H9.2a2 2 0 0 1 .281-.432l2.46-2.87A2 2 0 0 1 13 3.054ZM15 3v4a2 2 0 0 1-2 2H9v6a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"/></svg>',
        github: '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M12.006 2a9.847 9.847 0 0 0-6.484 2.44 10.32 10.32 0 0 0-3.393 6.17 10.48 10.48 0 0 0 1.317 6.955 10.045 10.045 0 0 0 5.4 4.418c.504.095.683-.223.683-.494 0-.245-.01-1.052-.014-1.908-2.78.62-3.366-1.21-3.366-1.21a2.711 2.711 0 0 0-1.11-1.5c-.907-.637.07-.621.07-.621.317.044.62.163.885.346.266.183.487.426.647.71.135.253.318.476.538.655a2.079 2.079 0 0 0 2.37.196c.045-.52.27-1.006.635-1.37-2.219-.259-4.554-1.138-4.554-5.07a4.022 4.022 0 0 1 1.031-2.75 3.77 3.77 0 0 1 .096-2.713s.839-.275 2.749 1.05a9.26 9.26 0 0 1 5.004 0c1.906-1.325 2.74-1.05 2.74-1.05.37.858.406 1.828.101 2.713a4.017 4.017 0 0 1 1.029 2.75c0 3.939-2.339 4.805-4.564 5.058a2.471 2.471 0 0 1 .679 1.897c0 1.372-.012 2.477-.012 2.814 0 .272.18.592.687.492a10.05 10.05 0 0 0 5.388-4.421 10.473 10.473 0 0 0 1.313-6.948 10.32 10.32 0 0 0-3.39-6.165A9.847 9.847 0 0 0 12.007 2Z" clip-rule="evenodd"/></svg>',
        error: '<svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="24" cy="24" r="21" fill="#FF5C5C" stroke="#D10000" stroke-width="2"/><path d="M16 16 L32 32 M32 16 L16 32" stroke="#FFFFFF" stroke-width="4" stroke-linecap="round"/></svg>',
        warning: '<svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M24 6 L44 42 L4 42 Z" fill="#FFD900" stroke="#CCAA00" stroke-width="2"/><path d="M24 16 L24 28" stroke="#000000" stroke-width="4" stroke-linecap="round"/><circle cx="24" cy="34" r="2.5" fill="#000000"/></svg>',
        question: '<svg width="48px" height="48px" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><g stroke-width="0"></g><g stroke-linecap="round" stroke-linejoin="round"></g><g><path d="M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z" fill="#1E90FF" stroke="#0000CD" stroke-width="2.448" stroke-linejoin="round"></path> <path d="M24 28.6249V24.6249C27.3137 24.6249 30 21.9386 30 18.6249C30 15.3112 27.3137 12.6249 24 12.6249C20.6863 12.6249 18 15.3112 18 18.6249" stroke="white" stroke-width="2.448" stroke-linecap="round" stroke-linejoin="round"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M24 37.6249C25.3807 37.6249 26.5 36.5056 26.5 35.1249C26.5 33.7442 25.3807 32.6249 24 32.6249C22.6193 32.6249 21.5 33.7442 21.5 35.1249C21.5 36.5056 22.6193 37.6249 24 37.6249Z" fill="white"></path> </g></svg>',
        info: '<svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="24" cy="24" r="21" fill="#4B9AE0" stroke="#3A7FB7" stroke-width="2"/><path d="M24 20 L24 38" stroke="#FFFFFF" stroke-width="4" stroke-linecap="round"/><circle cx="24" cy="14" r="2.5" fill="#FFFFFF"/></svg>',
      };
    let fileSystem, desktop;
    window.onload = () => {
      if (username === 'Sololearn') alert("!! Please read this !! \n\nHey! Hope you like what you'll see. Anyway, feel free to drop a comment with any suggestionsâ€”every idea is important to me! \n\nThanks for your time and support!");
      else if (username === '') {
        alert("Please wait while we perform system maintenance.\n\nThe application is temporarily unavailable. \nPlease try again in a few minutes.");
        return;
      }
      fileSystem = new FileSystem();
      desktop = new Desktop();
      new Terminal();
    }
    async function copyText(text) {
      let copySuccess = false;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(text);
          copySuccess = true;
        } catch {
          copySuccess = false;
        }
      }
      if (!copySuccess) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          if (document.execCommand('copy')) {
            copySuccess = true;
          }
        } catch {
          copySuccess = false;
        }
        document.body.removeChild(textArea);
      }
      return copySuccess;
    }
    class FileSystemClone {
      constructor() {
        this.root = fileSystem.globalRoot;
        const homeDir = this.root.children.find(d => d.name === 'home' && d.type === 'directory');
        if (homeDir) {
          this.path = '/home';
        } else {
          this.path = '/';
        }
      }
    }
    class FileSystem {
      constructor() {
        const savefs = this.getFileSystem();
        if (savefs !== null) {
          this.globalRoot = savefs;
        } else {
          this.globalRoot = this.createDirectory('root', { isSystem: true });
        }
        this.ensureRequiredFiles();
        if (!this.exists(this.globalRoot.children, 'bin')) {
          throw new Error('Failed to initialize file system');
        }
      }
      ensureRequiredFiles() {
        const requiredDirs = [
          { name: 'home', path: '/' },
          { name: 'bin', path: '/' }
        ];
        const requiredFiles = [
        {
          name: 'tiger_photo.png',
          content: 'https://dl.dropbox.com/scl/fi/5mgu2ty49y9xhvvm10b7k/1757933368173.jpg?rlkey=pfj4dtp5dfqkcvud6cs57ertk&st=qq0koisz',
          path: '/bin'
        },
        {
          name: 'tiger_video.mp4',
          content: 'https://dl.dropbox.com/scl/fi/5r13hlefcadlrm7qu43na/lion.mp4?rlkey=2tuwue1qtf3xjoy8kwdf1qzwj',
          path: '/bin'
        },
        {
          name: 'Kamin - ZetaMix (Sloved Reverb).mp3',
          content: 'https://dl.dropbox.com/scl/fi/a1rrytd8dggp07mug6kue/kamin.mp3?rlkey=b0bxdstk8eje3jj4z4uua54e5&st=gse4q6vp',
          path: '/bin'
        }];
        let needsSave = false;
        requiredDirs.forEach(dirConfig => {
          const fullPath = dirConfig.path === '/' ? `/${dirConfig.name}` : `${dirConfig.path}/${dirConfig.name}`;
          const dir = this._resolvePath(fullPath);
          if (!dir) {
            const parentDir = this._resolvePath(dirConfig.path);
            if (parentDir && parentDir.type === 'directory') {
              const newDir = this.createDirectory(dirConfig.name, { isSystem: dirConfig.name === 'bin' });
              parentDir.children.push(newDir);
              needsSave = true;
            }
          }
        });
        requiredFiles.forEach(fileConfig => {
          const fullPath = `${fileConfig.path}/${fileConfig.name}`;
          const file = this._resolvePath(fullPath);
          if (!file) {
            const targetDir = this._resolvePath(fileConfig.path);
            if (targetDir && targetDir.type === 'directory') {
              const newFile = this.createFile(fileConfig.name, fileConfig.content);
              targetDir.children.push(newFile);
              needsSave = true;
            }
          }
        });
        if (needsSave) {
          this.saveFileSystem();
        }
      }
      saveFileSystem() {
        try {
          localStorage.setItem("savefs", JSON.stringify(this.globalRoot));
          return true;
        } catch {
          return false;
        }
      }
      getFileSystem() {
        try {
          return JSON.parse(localStorage.getItem("savefs"));
        } catch {
          return null;
        }
      }
      asyncReadFile(path) {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            try {
              const file = this._resolvePath(path);
              if (!file || file.type !== 'file') {
                throw new Error(`File not found: ${path}`);
              }
              if (file.parameters.encoding === 'binary') {
                resolve(new Blob([file.content]));
              } else {
                resolve(file.content);
              }
            } catch (e) {
              reject(e);
            }
          }, 0);
        });
      }
      createDirectory(name, parameters = { isSystem: false }) {
        if (!this._validateName(name)) {
          throw new Error(`Invalid directory name: ${name}`);
        }
        return {
          name,
          type: 'directory',
          children: [],
          parameters
        };
      }
      createFile(name, content = '', parameters = {}) {
        if (!this._validateName(name)) {
          throw new Error(`Invalid file name: ${name}`);
        }
        const finalParameters = { ...{ isBinary: false, isSystem: false, encoding: "UTF-8" }, ...parameters };
        return {
          name,
          type: 'file',
          content: finalParameters.isBinary ? new Uint8Array(content) : String(content),
          parameters: finalParameters,
        };
      }
      _validateName(name) {
        name = name.trim();
        if (name.includes('/') || name === '.' || name === '..') return false;
        return true;
      }
      ls(path) {
        return this._resolvePath(path).children;
      }
      mkdirp(path) {
        const parts = path.split('/').filter(p => p);
        let current = this.globalRoot;
        for (const part of parts) {
          let dir = current.children.find(d => d.name === part && d.type === 'directory');
          if (!dir) {
            dir = this.createDirectory(part);
            current.children.push(dir);
          }
          current = dir;
        }
        return current;
      }
      mkdir(currentPath, name) {
        const targetDir = this._resolvePath(currentPath);
        if (!targetDir || targetDir.type !== 'directory') {
          throw new Error('Invalid path to create directory');
        }
        if (!this.exists(targetDir.children, name)) {
          const newDir = this.createDirectory(name);
          return targetDir.children.push(newDir);
        }
        return false;
      }
      exists(children, name) {
        return children.some(item => item.name === name);
      }
      findIndex(children, name) {
        return children.findIndex(item => item.name === name);
      }
      cd(currentPath, newPath) {
        if (typeof newPath !== 'string') {
          throw new Error('Path must be a string');
        }
        if (newPath === '/') {
          return '/';
        }
        let targetPath;
        if (newPath.startsWith('/')) {
          targetPath = newPath;
        } else {
          const parts = currentPath.split('/').filter(p => p);
          const newPathParts = newPath.split('/');
          for (const part of newPathParts) {
            if (part === '..') {
              if (parts.length > 0) {
                parts.pop();
              }
            } else if (part !== '.' && part !== '') {
              parts.push(part);
            }
          }
          targetPath = '/' + parts.join('/');
        }
        const targetDir = this._resolvePath(targetPath);
        if (targetDir && targetDir.type === 'directory') {
          return targetPath;
        }
        throw new Error(`Directory not found: ${newPath}`);
      }
      _findParent(targetNode, startNode = this.globalRoot) {
        if (startNode === targetNode) return null;
        
        const queue = [startNode];
        while (queue.length > 0) {
          const current = queue.shift();
          for (const child of current.children) {
            if (child === targetNode) {
              return current;
            }
            if (child.type === 'directory') {
              queue.push(child);
            }
          }
        }
        return null;
      }
      _resolvePath(path, startDir = this.globalRoot) {
        if (!path || path === '/') {
          return this.globalRoot;
        }
        const parts = path.split('/').filter(p => p !== '' && p !== '.');
        let current = startDir;
        for (const part of parts) {
          if (part === '..') {
            const parent = this._findParent(current);
            if (parent) {
              current = parent;
            }
          } else {
            const found = current.children.find(item => item.name === part);
            if (!found) return null;
            current = found;
          }
        }
        return current;
      }
      touch(currentPath, name) {
        const targetDir = this._resolvePath(currentPath);
        if (!targetDir || targetDir.type !== 'directory') {
          throw new Error('Invalid path to create file');
        }
        if (!this.exists(targetDir.children, name)) {
          const newFile = this.createFile(name);
          targetDir.children.push(newFile);
          this.saveFileSystem();
          return true;
        }
        return false;
      }
      rm(currentPath, name, recursive = false) {
        const targetDir = this._resolvePath(currentPath);
        if (!targetDir || targetDir.type !== 'directory') {
          throw new Error('Invalid path');
        }
        const index = this.findIndex(targetDir.children, name);
        if (index === -1) throw new Error("File or directory does not exist");
        const item = targetDir.children[index];
        if (item.type === 'directory') {
          if (item.parameters.isSystem === true) throw new Error("Can't remove system directory");
          if (item.children.length > 0 && !recursive) return false;
        } else if (item.type === 'file' && item.parameters.isSystem === true) {
          throw new Error("Can't remove system file");
        }
        targetDir.children.splice(index, 1);
        this.saveFileSystem();
        return true;
      }
      writeFile(fullPath, content, isBinary = false) {
        if (!fullPath) throw new Error('Full path is required to write a file.');
        const pathParts = fullPath.split('/').filter(p => p);
        if (pathParts.length === 0) throw new Error('Cannot write to root directory.');
        const fileName = pathParts.pop();
        const dirPath = '/' + pathParts.join('/');
        const targetDir = this._resolvePath(dirPath);
        if (!targetDir || targetDir.type !== 'directory') this.mkdirp(dirPath);
        const currentDir = this._resolvePath(dirPath);
        const existingFile = currentDir.children.find(f => f.name === fileName);
        if (existingFile) {
          existingFile.content = isBinary ? new Uint8Array(content) : String(content);
        } else {
          const newFile = this.createFile(fileName, content, { isBinary: isBinary });
          currentDir.children.push(newFile);
        }
        this.saveFileSystem();
        return true;
      }
      
      readFile(fullPath, options = {}) {
        const file = this._resolvePath(fullPath);
        if (!file || file.type !== 'file') return null;
        if (typeof file.content === 'string' && file.content.startsWith('http')) {
          return file.content;
        }
        if (options === 'base64' && file.parameters.encoding === 'binary') {
          return btoa(String.fromCharCode(...file.content));
        }
        if (options.asText && file.parameters.encoding === 'binary') {
          const decoder = new TextDecoder(options.encoding || 'UTF-8');
          return decoder.decode(file.content);
        }
        return file.content;
      }
      mv(sourceFullPath, targetFullPath) {
        const source = this._resolvePath(sourceFullPath);
        if (!source) {
          throw new Error(`Source path '${sourceFullPath}' not found`);
        }
        const targetParentPath = targetFullPath.split('/').slice(0, -1).join('/');
        const targetParent = this._resolvePath(targetParentPath);
        const targetName = targetFullPath.split('/').pop() || source.name;
        if (source.parameters.isSystem === true) {
          if (source.type === 'file') throw new Error("Can't move system file");
          else throw new Error("Can't move system directory");
        }
        if (!targetParent || targetParent.type !== 'directory') {
          throw new Error(`Invalid target path '${targetFullPath}'`);
        }
        if (source === targetParent.children.find(item => item.name === targetName)) {
          return true;
        }
        if (this.exists(targetParent.children, targetName)) {
          throw new Error(`Target '${targetName}' already exists`);
        }
        const sourceParent = this._findParent(source);
        if (!sourceParent) {
          throw new Error("Cannot move root directory");
        }
        sourceParent.children = sourceParent.children.filter(item => item !== source);
        source.name = targetName;
        targetParent.children.push(source);
        this.saveFileSystem();
        return true;
      }
      
      cp(currentPath, sourcePath, targetPath) {
        const source = this._resolvePath(sourcePath, this._resolvePath(currentPath));
        if (!source) throw new Error(`Source path '${sourcePath}' not found`);
        const targetParent = this._resolvePath(targetPath.split('/').slice(0, -1).join('/'), this._resolvePath(currentPath));
        const targetName = targetPath.split('/').pop() || source.name;
        if (!targetParent || targetParent.type !== 'directory') {
          throw new Error(`Invalid target path '${targetPath}'`);
        }
        if (this.exists(targetParent.children, targetName)) {
          throw new Error(`Target '${targetName}' already exists`);
        }
        const copy = this._deepCopy(source);
        copy.name = targetName;
        targetParent.children.push(copy);
        this.saveFileSystem();
        return true;
      }
      getItemSize(item) {
        if (item.type === "directory") return item.children ? item.children.length : 0;
        if (item.content instanceof Uint8Array) return item.content.length;
        if (typeof item.content === "string") return new TextEncoder().encode(item.content).length;
        return 0;
      }
      formatSize(bytes, type = null) {
        const units = {
          'B': 1,
          'KB': 1024,
          'MB': 1024 * 1024,
          'GB': 1024 * 1024 * 1024
        };
        if (type === "directory") return `${bytes} item${bytes !== 1 ? 's' : ''}`;
        if (bytes >= units['GB']) return `${(bytes / units['GB']).toFixed(2)} GB`;
        if (bytes >= units['MB']) return `${(bytes / units['MB']).toFixed(2)} MB`;
        if (bytes >= units['KB']) return `${(bytes / units['KB']).toFixed(2)} KB`;
        return `${bytes} B`;
      }
      async decodeContent(content, outputFormat) {
        if (!content) return null;
        if (content instanceof Uint8Array) {
          content = new Blob([content]);
        }
        switch (outputFormat) {
          case 'url':
            if (typeof content === 'string' && content.startsWith('http')) {
              return content;
            }
            if (content instanceof Blob) {
              return URL.createObjectURL(content);
            }
            throw new Error('Cannot convert this file content to a URL.');
          case 'text':
            if (typeof content === 'string') {
              return content;
            }
            if (content instanceof Blob) {
              return await content.text();
            }
            throw new Error('Cannot convert this file content to text.');
          case 'blob':
            if (content instanceof Blob) {
              return content;
            }
            if (typeof content === 'string') {
              return new Blob([content], {
                type: 'text/plain'
              });
            }
            throw new Error('Cannot convert this file content to a Blob.');
          case 'arraybuffer':
            if (content instanceof Blob) {
              return await content.arrayBuffer();
            }
            if (content instanceof Uint8Array) {
              return content.buffer;
            }
            throw new Error('Cannot convert this file content to an ArrayBuffer.');
          default:
            return content;
        }
      }
      getFileType(fileName) {
        const typeMap = {
          'unvalid': {
            type: 'unvalid',
            display: 'File'
          },
          'mp4': {
            type: 'video',
            display: 'MP4 Video'
          },
          'mov': {
            type: 'video',
            display: 'MOV Video'
          },
          'avi': {
            type: 'video',
            display: 'AVI Video'
          },
          'webm': {
            type: 'video',
            display: 'WebM Video'
          },
          'mp3': {
            type: 'audio',
            display: 'MP3 Audio'
          },
          'wav': {
            type: 'audio',
            display: 'WAV Audio'
          },
          'flac': {
            type: 'audio',
            display: 'FLAC Audio'
          },
          'm4a': {
            type: 'audio',
            display: 'M4A Audio'
          },
          'png': {
            type: 'image',
            display: 'PNG Image'
          },
          'jpg': {
            type: 'image',
            display: 'JPG Image'
          },
          'jpeg': {
            type: 'image',
            display: 'JPEG Image'
          },
          'gif': {
            type: 'image',
            display: 'GIF Image'
          },
          'txt': {
            type: 'text',
            display: 'Text File'
          },
          'log': {
            type: 'text',
            display: 'Log File'
          },
          'md': {
            type: 'text',
            display: 'Markdown'
          },
          'html': {
            type: 'text',
            display: 'HTML Document'
          },
          'css': {
            type: 'text',
            display: 'CSS Stylesheet'
          },
          'json': {
            type: 'text',
            display: 'JSON File'
          },
          'js': {
            type: 'executable',
            display: 'JavaScript'
          },
          'app': {
            type: 'executable',
            display: 'Application'
          },
          'zip': {
            type: 'archive',
            display: 'ZIP Archive'
          },
        };
        for (const ext of Object.keys(typeMap).sort((a, b) => b.length - a.length)) {
          if (fileName.toLowerCase().endsWith(`.${ext}`)) {
            return typeMap[ext];
          }
        }
        return typeMap['unvalid'];
      }
      openFile(path, fileType = 'auto') {
        if (!path) {
          throw new Error('Please specify a file path');
        }
        const file = this._resolvePath(path);
        if (!file || file.type !== 'file') {
          throw new Error(`File not found: ${path}`);
        }
        if (fileType === 'auto') {
          fileType = this.getFileType(file.name).type;
        }
        switch (fileType) {
          case 'video':
            new VideoPlayer(path);
            break;
          case 'audio':
            new AudioPlayer(path);
            break;
          case 'text':
            new TextEditor(path);
            break;
          case 'image':
            new ImageViewer(path);
            break;
          case 'executable':
            const confirmationMessage = `
 ðŸš¨ WARNING! ðŸš¨

You are about to execute JavaScript code from a file.
This is an extremely risky action if you do not trust the file's source 100%.

Malicious code can:
  - Steal your data (cookies, passwords, personal information).
  - Perform actions on your behalf on this site.
  - Damage the functionality of the page.

Proceed with execution only if you are ABSOLUTELY sure this file is safe?`;
            if (window.confirm(confirmationMessage)) {
              console.log("User confirmed execution. Running script...");
              try {
                (async function() {
                  fileSystem.asyncReadFile(path).then((content) => { return fileSystem.decodeContent(content, 'text'); }).then((content) => {
                    const app = new Function(content)();
                    if (app && typeof app.execute === 'function') {
                      app.execute();
                    }
                  })
                })();
              } catch (e) {
                throw new Error(`Execution error: ${e.message}`);
              }
            };
            break;
          default:
            this.showAppPicker(path);
        }
      }
      showAppPicker(path) {
        const dialog = document.createElement('div');
        dialog.className = 'app-picker-dialog';
        const trimName = (name, maxLength = 20) => {
          if (!name) return '';
          const lastDotIndex = name.lastIndexOf('.');
          if (lastDotIndex <= 0) {
            if (name.length > maxLength) {
              return name.substring(0, maxLength) + '...';
            }
            return name;
          }
          const fileNameWithoutExtension = name.substring(0, lastDotIndex);
          const fileExtension = name.substring(lastDotIndex + 1);
          if (fileNameWithoutExtension.length > maxLength) {
            return fileNameWithoutExtension.substring(0, maxLength) + '...' + fileExtension;
          }
          return name;
        };
        dialog.innerHTML = `
  <div class="app-picker-content">
    <h3>Select application for '${trimName(path.split('/').pop())}':</h3>
    <div class="app-list">
      <button class="app-option" data-type="text">Text Editor</button>
      <button class="app-option" data-type="image">Image Viewer</button>
      <button class="app-option" data-type="video">Video Player</button>
      <button class="app-option" data-type="audio">Audio Player</button>
      <button class="app-option" data-type="executable">Execute</button>
    </div>
    <button class="cancel-btn">Cancel</button>
  </div>`;
        dialog.querySelectorAll('.app-option').forEach(btn => {
          btn.addEventListener('click', () => {
            dialog.remove();
            this.openFile(path, btn.dataset.type);
          });
        });
        dialog.querySelector('.cancel-btn').addEventListener('click', () => dialog.remove());
        dialog.addEventListener('click', (e) => {
          if (e.target === dialog) dialog.remove();
        });
        document.body.appendChild(dialog);
      }
      getResolvedPath(fullPath, path) {
        if (!path || path === '/' || path.startsWith('/')) {
          return path;
        }
        const parts = fullPath.split('/').filter(p => p);
        const pathParts = path.split('/');
        for (const part of pathParts) {
          if (part === '..') {
            if (parts.length > 0) {
              parts.pop();
            }
          } else if (part !== '.' && part !== '') {
            parts.push(part);
          }
        }
        return '/' + parts.join('/');
      }
      async unarchive(file, onProgress) {
        const zip = new JSZip();
        const files = [];
        try {
          const content = await this.decodeContent(file.content, 'arraybuffer');
          const loadedZip = await zip.loadAsync(content, {
            update: function(metadata) {
              if (onProgress) {
                onProgress(metadata.loaded, metadata.total);
              }
            }
          });
          for (const [relativePath, zipEntry] of Object.entries(loadedZip.files)) {
            if (!zipEntry.dir) {
              const fileContent = await zipEntry.async('uint8array');
              files.push({ path: relativePath, content: fileContent, isDirectory: false });
            } else {
              files.push({ path: relativePath, isDirectory: true });
            }
          }
          return files;
        } catch (error) {
          throw new Error(`An unknown error occurred while unarchiving the file. Please check if the .zip archive is valid and not corrupted.`);
        }
      }
      _deepCopy(node) {
        const copy = {
          name: node.name,
          type: node.type,
          parameters: node.parameters
        };
        if (node.type === 'directory') {
          copy.children = node.children.map(child => this._deepCopy(child));
        } else if (node.type === 'file') {
          copy.content = node.content;
        }
        return copy;
      }
    }
    class Desktop {
      constructor() {
        this.desktop = document.createElement('div');
        this.desktop.className = "desktop";
        document.body.appendChild(this.desktop);
        const path = '/bin/';
        this.apps = {
          explorer: {
            name: "File Explorer",
            class: "explorer",
            icon: icons.explorer,
            handler: () => new FileExplorer()
          },
          terminal: {
            name: "Terminal",
            class: "terminal",
            icon: icons.terminal,
            handler: () => new Terminal()
          },
          editor: {
            name: "Text Editor",
            class: "text",
            icon: icons.text,
            handler: () => new TextEditor()
          },
          imageViewer: {
            name: "Image Viewer",
            class: "image",
            icon: icons.image,
            handler: () => fileSystem.openFile(path + 'tiger_photo.png', 'image')
          },
          videoPlayer: {
            name: "Video Player",
            class: "video",
            icon: icons.video,
            handler: () => fileSystem.openFile(path + 'tiger_video.mp4', 'video')
          },
          audioPlayer: {
            name: "Audio Player",
            class: "audio",
            icon: icons.audio,
            handler: () => fileSystem.openFile(path + 'Kamin - ZetaMix (Sloved Reverb).mp3', 'audio')
          },
          gitHubLink: {
            name: "Open Source",
            icon: icons.github,
            handler: () => {
              if (confirm("You will be redirected to the open-source code page on GitHub. \nPlease confirm the action."))
                window.open('https://github.com/Davidhaba/TermX', '_blank');
            }
          }
        };
        Object.entries(this.apps).forEach(([id, app]) => {
          this.createDesktopIcon(app);
        });
      }
      
      createDesktopIcon(app) {
        const icon = document.createElement("div");
        icon.className = "desktop-icon";
        if (app.class) icon.classList.add(app.class);
        const image = document.createElement("div");
        image.className = "image";
        if (app.icon) image.innerHTML = app.icon;
        icon.appendChild(image);
        const label = document.createElement("div");
        label.className = "label";
        if (app.name) label.innerHTML = app.name;
        icon.appendChild(label);
        if (app.handler && typeof app.handler === "function") icon.addEventListener("click", () => app.handler.call(this));
        this.desktop?.appendChild(icon);
      }
    }
    class Terminal {
      constructor() {
        this.appName = 'TermX';
        this.terminalApp = new Modal(this.appName);
        this.terminalWindow = this.terminalApp.appMain;
        this.terminalWindow.classList.add("padd");
        this.terminalMain = this.terminalApp.modWindow;
        this.updateTitle = this.terminalApp.updateTitle;
        this.history = [];
        this.historyIndex = -1;
        this.isDownloadedSpec = false;
        this.currentHint = null;
        this.init();
        this.commands = {
          help: {
            execute: this.help.bind(this),
            help: {
              description: "Show help information",
              usage: "help [command]",
              example: "help\nhelp cd"
            }
          },
          about: {
            execute: this.about.bind(this),
            help: {
              description: "Show information about the terminal",
              usage: "about"
            }
          },
          special: {
            execute: async () => {
              if (!this.isDownloadedSpec) {
                await this.simulateDownload(['3000', '10MB', 'Downloading...']);
                this.isDownloadedSpec = true;
              }
              this.isSpecialMode = true;
              this.addOutputLine('Entered special mode. Type "exit" to return.', 'info');
            },
            help: {
              description: "Enter special command mode",
              usage: "special",
            }
          },
          exit: {
            execute: this.exit.bind(this),
            help: {
              description: "Exit the terminal",
              usage: "exit",
            }
          },
          clear: {
            execute: this.clear.bind(this),
            help: {
              description: "Clear terminal screen",
              usage: "clear",
            }
          },
          ls: {
            execute: this.ls.bind(this),
            help: {
              description: "List directory contents",
              usage: "ls",
              example: "ls"
            }
          },
          mkdir: {
            execute: this.mkdir.bind(this),
            help: {
              description: "Create new directory",
              usage: "mkdir <directory_name>",
              example: "mkdir new_folder"
            }
          },
          cd: {
            execute: this.cd.bind(this),
            help: {
              description: "Change current directory",
              usage: "cd <path>",
              example: "cd folder\ncd .."
            }
          },
          touch: {
            execute: this.touch.bind(this),
            help: {
              description: "Create new empty file",
              usage: "touch <file_name>",
              example: "touch file.txt"
            }
          },
          rm: {
            execute: this.rm.bind(this),
            help: {
              description: "Remove file or directory",
              usage: "rm [-r] <path>",
              example: "rm old_file\nrm -r old_folder"
            }
          },
          echo: {
            execute: this.echo.bind(this),
            help: {
              description: "Display message or write text to file",
              usage: "echo [text] > [filename]",
              example: 'echo Hello World\necho Hello World > file.txt'
            }
          },
          cat: {
            execute: this.cat.bind(this),
            help: {
              description: "Show file contents",
              usage: "cat <file_name>",
              example: "cat file.txt"
            }
          },
          pwd: {
            execute: this.pwd.bind(this),
            help: {
              description: "Print current working directory",
              usage: "pwd",
            }
          },
          mv: {
            execute: this.mv.bind(this),
            help: {
              description: "Move or rename files and directories",
              usage: "mv <source> <target>",
              example: "mv old.txt new.txt\nmv file.txt dir/"
            }
          },
          cp: {
            execute: this.cp.bind(this),
            help: {
              description: "Copy files and directories",
              usage: "cp <source> <target>",
              example: "cp file.txt backup/\ncp -r dir/ backup/"
            }
          },
          progress: {
            execute: async (args) => {
              try {
                await this.simulateDownload(args);
              } catch (error) {
                this.addOutputLine(error.message, 'error');
              }
            },
            help: {
              description: "Simulate file download with progress bar",
              usage: "progress [duration] [size] [label]",
              example: "progress 5000 20MB Downloading..."
            }
          },
          notepad: {
            execute: (args) => {
              const path = fileSystem.getResolvedPath(this.context.path, args[0]);
              try {
                if (path) {
                  new TextEditor(path);
                } else {
                  new TextEditor();
                }
              } catch (error) {
                this.addOutputLine(error.message, 'error');
              }
            },
            help: {
              description: "Open file in text editor",
              usage: "notepad [file_path]",
              example: "notepad\nnotepad ../folder/file.txt"
            }
          },
          run: {
            execute: (args) => fileSystem.openFile(fileSystem.getResolvedPath(this.context.path, args[0]), 'executable'),
            help: {
              description: "Execute application",
              usage: "run <file_path>",
              example: "run app.js"
            }
          },
          open: {
            execute: (args) => fileSystem.openFile(fileSystem.getResolvedPath(this.context.path, args[0]), args[1]),
            help: {
              description: "Open any file (auto-detect type)",
              usage: "open <file_path> [file_type](audio, video, image, text or executable)",
              example: "open document.txt\nopen folder/file text"
            }
          },
          download: {
            execute: this.download.bind(this),
            help: {
              description: "Download file from URL",
              usage: "download <url> [filename]",
              example: "download https://example.com/file.txt\n" +
                "download https://example.com/image.png myimage.png"
            }
          },
          unarchive: {
            execute: this.unarchive.bind(this),
            help: {
              description: "Extract a .zip archive.",
              usage: "unarchive <filename>",
              example: "unarchive archive.zip"
            }
          },
        };
        this.isSpecialMode = false;
        this.specialCommands = {
          exit: {
            execute: () => {
              this.isSpecialMode = false;
              this.addOutputLine('Exited special mode', 'info');
            },
            help: {
              description: "Exit special mode",
              usage: "exit",
            }
          },
          help: {
            execute: this.help.bind(this),
            help: {
              description: "Show help information",
              usage: "help [command]",
              example: "help\nhelp exit"
            }
          },
          calc: {
            execute: (args) => {
              try {
                const [mathExpression, result] = this.safeEval(args.join(' '));
                this.addOutputLine(`${mathExpression} = ${result}`);
              } catch (error) {
                this.addOutputLine(error.message, 'error');
              }
            },
            help: {
              description: "Calculate math expression",
              usage: "calc <expression>",
              example: "1+1\ncalc 2*(3+4)"
            }
          }
        };
      }
      init() {
        this.terminalApp.setupExitBtn();
        this.terminalApp.setApp();
        this.terminalApp.setupInfoBtn('TermX',
          'TermX is a powerful command-line interface for interacting with the system. It supports a variety of commands for file and directory management (ls, cd, mkdir, rm, mv, cp), text manipulation (echo, cat, edit), and other utilities (help, about, clear). You can use it to perform complex operations, manage files, and even download content from the internet. Use the "help" command to see all available commands and their usage.'
        );
        this.context = new FileSystemClone();
        this.about();
        this.addOutputLine("Type 'help' for help");
        this.createInputLine();
        this.placeCaretAtEnd(this.input);
        this.terminalMain.addEventListener('keyup', () => this.placeCaretAtEnd(this.input));
        this.terminalWindow.addEventListener('click', () => this.input.focus());
        
        const keyboardControls = document.createElement('div');
        keyboardControls.classList.add("keyboard-controls");
        keyboardControls.innerHTML = `
            <button data-key="ArrowUp">${icons.arrowUp}</button>
            <button data-key="ArrowDown">${icons.arrowDown}</button>
            <button data-key="ArrowLeft">${icons.arrowLeft}</button>
            <button data-key="ArrowRight">${icons.arrowRight}</button>
            <button data-key="Tab">Tab</button>
            <button data-key="Enter" style="padding: 5px 15px;">${icons.enter}</button>
        `;
        this.terminalMain.appendChild(keyboardControls);
        let lastWinHeight = window.innerHeight;
        window.addEventListener('resize', () => {
          const currentHeight = window.innerHeight;
          if (currentHeight < lastWinHeight) {
            keyboardControls.classList.add('visible');
          } else {
            keyboardControls.classList.remove('visible');
          }
          lastWinHeight = currentHeight;
        });
        keyboardControls.addEventListener('touchstart', (e) => {
          if (e.target.tagName === 'BUTTON') e.target.classList.add("active");
        });
        keyboardControls.addEventListener('touchend', (e) => {
          const button = e.target.tagName === 'BUTTON' ? e.target : e.target.closest('button');
          if (button) {
            button.classList.remove("active");
            e.preventDefault();
            const key = e.target.dataset.key;
            if (!this.input) return;
            if (key === 'ArrowLeft') {
              const start = this.input.selectionStart;
              this.input.selectionEnd = start > 0 ? start - 1 : 0;
            } else if (key === 'ArrowRight') {
              const end = this.input.selectionEnd;
              const textLength = this.input.textContent.length;
              this.input.selectionStart = end < textLength ? end + 1 : textLength;
            } else {
              this.input.dispatchEvent(new KeyboardEvent('keydown', {
                key: key,
                bubbles: true,
                cancelable: true
              }));
            }
          }
        });
      }
      exit() {
        this.addOutputLine('Closing terminal...', 'info');
        this.terminalApp.handleClose();
      }
      placeCaretAtEnd(input) {
        if (input) {
          input.focus();
          if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
            let range = document.createRange();
            range.selectNodeContents(input);
            range.collapse(false);
            let sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          }
        }
      }
      createInputLine() {
        this.terminalApp.updateTitle(this.appName);
        const line = document.createElement('div');
        line.className = 'i-line';
        
        this.prompt = document.createElement('span');
        this.prompt.className = 'prompt';
        this.updatePrompt();
        
        this.input = document.createElement('span');
        this.input.className = 'stdin';
        this.input.contentEditable = true;
        this.input.setAttribute('autocorrect', 'off');
        this.input.setAttribute('autocapitalize', 'off');
        this.input.setAttribute('spellcheck', 'false');
        this.input.setAttribute('autocomplete', 'off');
        this.input.setAttribute('enterkeyhint', 'done');
        this.input.spellcheck = false;
        this.input.autocapitalize = 'none';
        this.input.autocorrect = 'off';
        
        line.appendChild(this.prompt);
        line.appendChild(this.input);
        this.terminalWindow.appendChild(line);
        
        this.input.addEventListener('input', () => this.updateHint());
        this.input.addEventListener('keydown', this.handleInput.bind(this));
        this.input.addEventListener('mouseup', () => this.placeCaretAtEnd(this.input));
      }
      
      updatePrompt() {
        if (!this.isSpecialMode) this.prompt.textContent = `${this.appName}@${username}:${this.context.path}$`;
        else this.prompt.textContent = ">>>";
      }
      handleInput(e) {
        this.updatePrompt();
        switch (e.key) {
          case 'Enter':
            e.preventDefault();
            this.executeCommand(this.input.textContent.trim());
            this.updateHint();
            break;
          case 'ArrowUp':
            e.preventDefault();
            this.navigateHistory(-1);
            break;
          case 'ArrowDown':
            e.preventDefault();
            this.navigateHistory(1);
            break;
          case 'ArrowLeft':
            e.preventDefault();
            break;
          case 'ArrowRight':
            e.preventDefault();
            this.handleTab();
            break;
          case 'Tab':
            e.preventDefault();
            this.handleTab();
            break;
        }
      }
      addOutputLine(text, type = 'normal') {
        const line = document.createElement('div');
        line.className = 'o-line';
        if (type !== 'normal') {
          const badge = document.createElement('span');
          badge.className = `badge ${type}`;
          if (type === 'success') {
            badge.textContent = 'âœ“';
          } else if (type === 'error') {
            badge.textContent = '!';
          } else if (type === 'info') {
            badge.textContent = 'i';
          }
          line.appendChild(badge);
        }
        const textNode = document.createTextNode(text);
        line.appendChild(textNode);
        this.terminalWindow.appendChild(line);
      }
      createNewInputLine() {
        this.input.contentEditable = false;
        this.createInputLine();
        this.placeCaretAtEnd(this.input);
      }
      scrollToBottom() {
        this.terminalWindow.scrollTop = this.terminalWindow.scrollHeight;
      }
      navigateHistory(direction) {
        this.historyIndex = Math.max(0,
          Math.min(this.history.length, this.historyIndex + direction));
        if (this.historyIndex >= 0 && this.historyIndex !== this.history.length) {
          const history = this.history[this.historyIndex];
          if (history) this.input.textContent = history;
        } else {
          this.input.textContent = '';
        }
        this.updateHint();
        this.placeCaretAtEnd(this.input);
      }
      
      parseFullArguments(commandStr) {
        const parts = [];
        let inQuotes = false;
        let currentPart = '';
        for (let i = 0; i < commandStr.length; i++) {
          const char = commandStr[i];
          if (char === '"' || char === "'") {
            inQuotes = !inQuotes;
            if (inQuotes === false) {
              if (currentPart.length > 0) {
                parts.push(currentPart);
                currentPart = '';
              }
            }
          } else if (char === ' ' && !inQuotes) {
            if (currentPart.length > 0) {
              parts.push(currentPart);
            }
            currentPart = '';
          } else {
            currentPart += char;
          }
        }
        if (currentPart.length > 0) {
          parts.push(currentPart);
        }
        return parts;
      }
      
      async executeCommand(fullCommand) {
        this.scrollToBottom();
        this.input.contentEditable = false;
        if (this.history[this.history.length - 1] !== fullCommand) {
          this.history.push(fullCommand);
        }
        this.historyIndex = this.history.length;
        const commandChain = fullCommand.split('&&').map(cmd => cmd.trim()).filter(cmd => cmd);
        for (const commandStr of commandChain) {
          const fullArgs = this.parseFullArguments(commandStr);
          const command = fullArgs[0];
          const args = fullArgs.slice(1);
          try {
            this.terminalApp.updateTitle(command + ' - ' + this.appName);
            if (this.isSpecialMode) {
              if (!this.specialCommands[command]) {
                const [mathExpression, result] = this.safeEval(fullCommand);
                this.addOutputLine(`${mathExpression} = ${result}`);
                this.scrollToBottom();
              } else {
                await this.specialCommands[command].execute(args);
              }
            } else {
              if (this.commands[command]) {
                await this.commands[command].execute(args);
              } else {
                this.addOutputLine(`'${command.length > 15 ? command.substring(0, 15) + '...' : command}' is not recognized as a command`, 'error');
              }
            }
          } catch (error) {
            this.addOutputLine(error.message, 'error');
            break;
          }
        }
        this.createNewInputLine();
        this.scrollToBottom();
      }
      safeEval(expression) {
        const mathExpression = expression.replace(/[^0-9+\-*/%e^().\s]/g, '');
        if (mathExpression.trim() === '') {
          throw new Error("No valid mathematical expression to evaluate.");
        }
        try {
          const result = new Function(`"use strict"; return (${mathExpression})`)();
          return [mathExpression, result];
        } catch (error) {
          throw new Error(`Evaluation error: ${error.message}`);
        }
      }
      help(args) {
        let cmdSet = this.isSpecialMode ? this.specialCommands : this.commands;
        if (args.length === 0) {
          this.addOutputLine('Available commands:', 'info');
          this.addOutputLine('\n' + 'Command'.padEnd(11) + 'Description');
          Object.entries(cmdSet).forEach(([cmd, data]) => {
            this.addOutputLine(`${cmd?.padEnd(10)} - ${data?.help?.description ?? '...'}`);
          });
          this.addOutputLine('\nUse "help <command>" for details');
        } else {
          const command = args[0];
          if (cmdSet[command]) {
            const info = cmdSet[command].help;
            const des = info?.description;
            const us = info?.usage;
            const ex = info?.example?.replace(/\n/g, '\n  ');
            this.addOutputLine("Help for: " + command, 'info');
            if (des) this.addOutputLine("Description: " + des);
            if (us) this.addOutputLine(`Usage:      ${us}`);
            if (ex) this.addOutputLine(`Examples:\n  ${ex}`);
          } else {
            this.addOutputLine(`Command '${command}' not found`, 'error');
          }
        }
      }
      clear() {
        this.terminalWindow.innerHTML = '';
        this.addOutputLine('Terminal cleared', 'info');
      }
      about() {
        this.addOutputLine(`TermX ${ver} (by David)`, 'info');
      }
      formatItemInfo(item) {
        return fileSystem.formatSize(fileSystem.getItemSize(item), item.type);
      }
      ls() {
        const files = fileSystem.ls(this.context.path);
        const currentDir = fileSystem._resolvePath(this.context.path);
        let parentDir;
        if (this.context.path !== '/') {
          parentDir = fileSystem._resolvePath(fileSystem._findParent(this.context.path));
        }
        if (!parentDir && (!files.length || files.length === 0)) {
          this.addOutputLine("Directory is empty.");
          return;
        }
        if (currentDir)
          this.addOutputLine('.'.padEnd(10) + ` [Current Directory] [${this.formatItemInfo(currentDir)}]`);
        if (parentDir)
          this.addOutputLine('..'.padEnd(10) + ` [Parent Directory] [${this.formatItemInfo(parentDir)}]`);
        files.forEach(file => {
          this.addOutputLine(file.name.padEnd(10) + ` [${file.type}] [${this.formatItemInfo(file)}]`);
        });
      }
      mkdir(args) {
        if (args.length === 0) {
          this.addOutputLine('Please specify directory name', 'error');
          return;
        }
        const success = fileSystem.mkdir(this.context.path, args[0]);
        if (success) {
          this.addOutputLine(`Directory '${args[0]}' created`);
        } else {
          this.addOutputLine(`Directory '${args[0]}' already exists`, 'error');
        }
      }
      cd(args) {
        if (args.length === 0) {
          this.addOutputLine('Please specify path', 'error');
          return;
        }
        const newPath = fileSystem.cd(this.context.path, args[0]);
        if (!newPath) {
          this.addOutputLine(`Invalid path: ${args[0]}`, 'error');
        }
        this.context.path = newPath;
      }
      touch(args) {
        if (args.length === 0) {
          throw new Error('Please specify filename');
        }
        const success = fileSystem.touch(this.context.path, args[0]);
        if (success) {
          this.addOutputLine(`File '${args[0]}' created`);
        } else {
          this.addOutputLine(`File '${args[0]}' already exists`, 'error');
        }
      }
      rm(args) {
        if (args.length === 0) {
          throw new Error('Please specify path');
        }
        let recursive = false;
        let success;
        const targetIndex = args.findIndex(arg => arg !== '-r');
        if (targetIndex !== 0) {
          recursive = true;
          args = args.slice(targetIndex);
        }
        try {
          success = fileSystem.rm(this.context.path, args[0], recursive);
        } catch (e) {
          throw new Error(e);
        }
        if (!success) {
          const errorMsg = recursive ?
            "Can't remove directory" :
            "Directory not empty, use -r for recursive removal";
          throw new Error(errorMsg);
        }
        this.addOutputLine(`'${args[0]}' removed`);
      }
      echo(args) {
        const input = args.join(' ');
        if (!input.includes('>')) {
          this.addOutputLine(input);
          return;
        }
        const parts = input.split(' > ').map(p => p.trim());
        if (parts.length !== 2 || parts[0] === '' || parts[1] === '') {
          throw new Error('Invalid syntax. Use: echo [text] > [filename]');
        }
        const [text, filePath] = parts;
        const fullPath = fileSystem.getResolvedPath(this.context.path, filePath);
        const target = fileSystem._resolvePath(fullPath);
        const success = fileSystem.writeFile(fullPath, text);
        if (!success) throw new Error(`Failed to write to file '${fullPath}'`);
        this.addOutputLine(`Content written to '${fullPath}'`);
      }
      async cat(args) {
        if (args.length === 0) {
          throw new Error('Please specify filename');
        }
        const content = await fileSystem.decodeContent(fileSystem.readFile(fileSystem.getResolvedPath(this.context.path, args[0]), { asText: true }),
          'text');
        if (content === null) {
          throw new Error(`File '${args[0]}' not found`);
        }
        this.addOutputLine(content);
      }
      pwd() {
        this.addOutputLine('Current directory: ' + this.context.path);
      }
      createProgressBar(label) {
        const progressBar = document.createElement('div');
        progressBar.className = 'progress-bar';
        progressBar.innerHTML = `
            <div class="progress-column">
                <div class="progress-label">${label}</div>
                <div class="progress-container">
                  <div class="progress-track">
                      <div class="progress-fill"></div>
                  </div>
                  <div class="progress-details">
                      <span class="progress-percent">0%</span>
                      <span class="progress-size">0/0</span>
                  </div>
                </div>
            </div>
        `;
        this.terminalWindow.appendChild(progressBar);
        return progressBar;
      }
      updateProgressBar(progressBar, percent, loaded, total, label) {
        const percentElement = progressBar.querySelector('.progress-percent');
        const sizeElement = progressBar.querySelector('.progress-size');
        const fillElement = progressBar.querySelector('.progress-fill');
        const formattedPercent = Math.floor(percent);
        const formattedLoaded = fileSystem.formatSize(loaded);
        const formattedTotal = total > 0 ? fileSystem.formatSize(total) : '??';
        fillElement.style.width = `${percent}%`;
        percentElement.textContent = `${formattedPercent}%`;
        sizeElement.textContent = `${formattedLoaded}/${formattedTotal}`;
        this.terminalApp.updateTitle(`${label} ${formattedPercent}% - ` + this.appName);
      }
      async simulateDownload(args) {
        try {
          const duration = args[0] ? parseInt(args[0]) : 5000;
          const size = this.parseSize(args[1] || '5MB');
          const label = args.slice(2).join(' ') || "Simulation download";
          const progressBar = this.createProgressBar(label);
          let loaded = 0;
          const startTime = Date.now();
          const updateInterval = 100;
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
          while (true) {
            const elapsed = Date.now() - startTime;
            const percent = Math.min(100, (elapsed / duration) * 100);
            loaded = Math.min(size, (size * percent) / 100);
            this.updateProgressBar(progressBar, percent, loaded, size, label);
            if (percent >= 100) break;
            await delay(updateInterval);
          }
          this.addOutputLine("Download complete!", 'success');
        } catch (error) {
          this.addOutputLine(`Simulation error: ${error.message}`, 'error');
        }
      }
      parseSize(sizeStr) {
        const units = {
          'B': 1,
          'KB': 1024,
          'MB': 1024 * 1024,
          'GB': 1024 * 1024 * 1024
        };
        const match = sizeStr.match(/^(\d+)([KMGT]?B)$/i);
        if (!match) throw new Error('Invalid size format');
        const value = parseInt(match[1]);
        const unit = match[2].toUpperCase();
        if (!units[unit]) throw new Error('Unknown unit');
        return value * units[unit];
      }
      removeHint() {
        try {
          if (this.currentHint) {
            this.currentHint.remove();
            this.currentHint = null;
          }
        } catch {}
      }
      updateHint() {
        try {
          this.removeHint();
          const hint = this.getHints(this.input.textContent)[0];
          if (!hint || hint === '') return;
          this.currentHint = document.createElement('span');
          this.currentHint.className = 'stdin-hint';
          this.currentHint.textContent = hint;
          this.input.parentNode.appendChild(this.currentHint);
        } catch {
          this.removeHint();
        }
      }
      getHints(text) {
        if (!text) return null;
        const parts = text.split(' ');
        const currentWord = parts[parts.length - 1];
        const commands = this.isSpecialMode ? this.specialCommands : this.commands;
        if (parts.length === 1) {
          return Object.keys(commands)
            .filter(cmd => cmd.startsWith(currentWord))
            .map(cmd => cmd.slice(currentWord.length));
        }
        const command = parts[0];
        if (commands[command]) {
          return this.getCommandHints(command, parts.slice(1), currentWord);
        }
        return [''];
      }
      getCommandHints(command, args, currentWord) {
        switch (command) {
          case 'help':
            if (args.length <= 1)
              return Object.keys(this.isSpecialMode ? this.specialCommands : this.commands).filter(cmd => cmd.startsWith(currentWord)).map(cmd => cmd.slice(currentWord.length));
          case 'cd':
            if (args.length <= 1)
              return fileSystem.ls(this.context.path).filter(f => f.type === 'directory' && f.name.startsWith(currentWord)).map(f => f.name.slice(currentWord.length));
          case 'cat':
          case 'notepad':
          case 'run':
          case 'open':
          case 'unarchive':
            if (args.length <= 1)
              return fileSystem.ls(this.context.path).filter(f => f.type === 'file' && f.name.startsWith(currentWord)).map(f => f.name.slice(currentWord.length));
          case 'echo':
            if (args.length <= 2)
              return [];
          case 'rm':
          case 'cp':
          case 'mv':
            return fileSystem.ls(this.context.path).filter(f => f.name.startsWith(currentWord)).map(f => f.name.slice(currentWord.length));
          case 'calc':
            return ['+', '-', '*', '/', '%'].filter(op => op.startsWith(currentWord)).map(op => op.slice(currentWord.length));
          default:
            return [];
        }
      }
      handleTab() {
        if (this.currentHint) {
          const hintText = this.currentHint.textContent;
          this.input.textContent += hintText;
          this.updateHint();
          this.placeCaretAtEnd(this.input);
        }
      }
      mv(args) {
        if (args.length < 2) {
          throw new Error('Usage: mv [source] [target]');
        }
        const [source, target] = args;
        const success = fileSystem.mv(fileSystem.getResolvedPath(this.context.path, source), fileSystem.getResolvedPath(this.context.path, target));
        if (success) {
          this.addOutputLine(`Moved '${source}' to '${target}'`);
        }
      }
      cp(args) {
        if (args.length < 2) {
          throw new Error('Usage: cp [source] [target]');
        }
        const [source, target] = args;
        const success = fileSystem.cp(this.context.path, source, target);
        if (success) {
          this.addOutputLine(`Copied '${source}' to '${target}'`);
        }
      }
      async download(args) {
        if (args.length < 1) throw new Error('Usage: download [url] [filename]');
        const [url, filePath] = args;
        try {
          const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
          this.addOutputLine(`Starting download via proxy: ${url}`, 'info');
          const fullPath = fileSystem.getResolvedPath(this.context.path, filePath || url.split('/').pop());
          const progressBar = this.createProgressBar(fullPath);
          const response = await fetch(proxyUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          if (!response.body) throw new Error('No response body');
          const total = parseInt(response.headers.get('Content-Length') || '0');
          const reader = response.body.getReader();
          const chunks = [];
          let loaded = 0;
          while (true) {
            const {
              done,
              value
            } = await reader.read();
            if (done) break;
            chunks.push(value);
            loaded += value.length;
            const percent = total > 0 ? (loaded / total) * 100 : 0;
            this.updateProgressBar(progressBar, percent, loaded, total, fullPath);
          }
          const blob = new Blob(chunks);
          const content = new Uint8Array(await blob.arrayBuffer());
          const success = fileSystem.writeFile(fullPath, content, true);
          if (!success) throw new Error('Failed to save file');
          this.addOutputLine(`Download complete: ${fullPath}`, 'success');
        } catch (error) {
          this.addOutputLine(`Download failed: ${error.message}`, 'error');
        }
      }
      async unarchive(args) {
        if (args.length < 1) {
          this.addOutputLine('Usage: unarchive <filename>', 'error');
          return;
        }
        const fileName = args[0];
        try {
          const fullPath = fileSystem.getResolvedPath(this.context.path, fileName);
          const file = fileSystem._resolvePath(fullPath);
          if (!file || file.type !== 'file') {
            throw new Error(`File not found: ${fileName}`);
          }
          this.addOutputLine(`Unpacking ${fileName}...`, 'info');
          const progressBar = this.createProgressBar(fileName);
          const extractedFiles = await fileSystem.unarchive(file, (processed, total) => {
            this.updateProgressBar(progressBar, (processed / total) * 100, processed, total, fileName);
          });
          for (const item of extractedFiles) {
            if (item.isDirectory) {
              fileSystem.mkdirp(fileSystem.getResolvedPath(this.context.path, item.path));
            } else {
              const newFilePath = fileSystem.getResolvedPath(this.context.path, item.path);
              fileSystem.mkdirp(newFilePath.split('/').slice(0, -1).join('/'));
              fileSystem.writeFile(newFilePath, item.content, true);
            }
          }
          this.addOutputLine(`Successfully unarchived ${fileName} into ${this.context.path}`, 'success');
          this.updateProgressBar(progressBar, 100, extractedFiles.length, extractedFiles.length, fileName);
        } catch (error) {
          this.addOutputLine(error.message, 'error');
        }
      }
    }
  </script>
</body>

</html>